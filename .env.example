# Default values are optimized for production to avoid having to configure
# much in production.
#
# However it should be easy to get going in development too. If you see an
# uncommented option that means it's either mandatory to set it or it's being
# overwritten in development to make your life easier.

# Rather than use the directory name, let's control the name of the project.
COMPOSE_PROJECT_NAME=gg2-assembler

# In development avoid writing out bytecode to __pycache__ directories.
PYTHONDONTWRITEBYTECODE=true

# You should generate a random string of 99+ characters for this value in prod.
API_SECRET=THIS IS NOT SECRET

DATABASE_URL=postgresql://postgres:abcdef@postgres:5432/gg2

DOCKER_FRONTEND_PORT_FORWARD=49999:49999

# Which environment is running? These should be "development" or "production".
#export NODE_ENV=production
NODE_ENV=development

# In development with Docker Desktop / Linux the default value should work.
# If you have Docker running in a custom VM, put the VM's IP here instead.
#
# In production you'll want to set this to your domain name or whatever you
# plan to access in your browser, such as example.com.
#export SERVER_NAME=localhost:8000

# How many workers and threads should your app use? WEB_CONCURRENCY defaults
# to the server's CPU count * 2. That is a good starting point. In development
# it's a good idea to use 1 to avoid race conditions when debugging.
NUM_WORKERS=1
#export PYTHON_MAX_THREADS=1

# You'll always want to set POSTGRES_USER and POSTGRES_PASSWORD since the
# postgres Docker image uses them for its default database user and password.
POSTGRES_USER=postgres
POSTGRES_PASSWORD=abcdef
#POSTGRES_HOST=postgres
#POSTGRES_PORT=5432
POSTGRES_DB=keycloak

# Should Docker restart your containers if they go down in unexpected ways?
#export DOCKER_RESTART_POLICY=unless-stopped
DOCKER_RESTART_POLICY=no

# What healthcheck test command do you want to run? In development, having it
# curl your web server will result in a lot of log spam, so setting it to
# /bin/true is an easy way to make the healthcheck do basically nothing.
#DOCKER_WEB_HEALTHCHECK_TEST=curl localhost:8000/up
DOCKER_WEB_HEALTHCHECK_TEST=/bin/true

# What ip:port should be published back to the Docker host for the app server?
# If you're using Docker Toolbox or a custom VM you can't use 127.0.0.1. This
# is being overwritten in dev to be compatible with more dev environments.
#
# If you have a port conflict because something else is using 8000 then you
# can either stop that process or change this 8000 to be something else.
#
# Use the default in production to avoid having gunicorn directly accessible to
# the internet since it'll very likely be behind nginx or a load balancer.
#DOCKER_WEB_PORT_FORWARD=127.0.0.1:8000
DOCKER_WEB_PORT_FORWARD=8000

# What volume path should be used? In development we want to volume mount
# everything so we can develop our code without rebuilding our Docker images.
#export DOCKER_WEB_VOLUME=./public:/app/public
DOCKER_WEB_VOLUME=.:/app

# What CPU and memory constraints will be added to your services? When left at
# 0, they will happily use as much as needed.
#DOCKER_WEB_CPUS=0
#DOCKER_WEB_MEMORY=0
